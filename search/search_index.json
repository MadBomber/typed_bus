{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TypedBus","text":"<p>Async pub/sub message bus with typed channels, ACK-based delivery, and dead letter queues for Ruby.</p> <p>Built on the async gem with fiber-only concurrency. No mutexes, no threads. All state lives within a single Async reactor.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed channels \u2014 constrain messages to a specific class; mismatches raise at the publish site</li> <li>Explicit acknowledgment \u2014 subscribers must <code>ack!</code> or <code>nack!</code> each delivery</li> <li>Dead letter queues \u2014 failed and timed-out deliveries collect for inspection or retry</li> <li>Backpressure \u2014 bounded channels block publishers when capacity is reached</li> <li>Adaptive throttling \u2014 asymptotic backoff slows publishers as channels fill</li> <li>Three-tier configuration \u2014 global, bus, and channel-level defaults with cascading inheritance</li> <li>Per-channel stats \u2014 published, delivered, nacked, timed_out, dead_lettered, throttled</li> <li>Structured logging \u2014 optional Ruby Logger integration across all components</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require \"typed_bus\"\n\nTypedBus.configure do |config|\n  config.timeout   = 10\n  config.log_level = Logger::INFO\nend\n\nbus = TypedBus::MessageBus.new\nbus.add_channel(:events, type: String)\n\nbus.subscribe(:events) do |delivery|\n  puts delivery.message\n  delivery.ack!\nend\n\nAsync do\n  bus.publish(:events, \"hello world\")\nend\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.2.0</li> <li>async ~&gt; 2.0</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"concepts/","title":"Concepts","text":"<p>TypedBus is built around a small set of core concepts. Understanding these makes the entire library predictable.</p>"},{"location":"concepts/#channels","title":"Channels","text":"<p>A channel is a named pub/sub topic. Publishers send messages to a channel; subscribers receive them. Each channel can optionally enforce a type constraint on its messages.</p> <p>Channels are the unit of configuration \u2014 each has its own timeout, backpressure limit, and throttle setting.</p>"},{"location":"concepts/#deliveries","title":"Deliveries","text":"<p>When a message is published to a channel with subscribers, each subscriber receives a Delivery envelope wrapping the original message. The subscriber must explicitly resolve the delivery by calling <code>ack!</code> (success) or <code>nack!</code> (failure).</p> <p>If neither is called before the channel's timeout expires, the delivery auto-nacks.</p>"},{"location":"concepts/#delivery-tracker","title":"Delivery Tracker","text":"<p>A DeliveryTracker aggregates the responses from all subscribers for a single published message. A message is considered \"delivered\" only when every subscriber has ACKed. If any subscriber NACKs, the failed deliveries route to the dead letter queue.</p>"},{"location":"concepts/#dead-letter-queue","title":"Dead Letter Queue","text":"<p>Every channel has a Dead Letter Queue (DLQ) that collects failed deliveries. Entries arrive from:</p> <ul> <li>Explicit <code>nack!</code> calls</li> <li>Delivery timeouts (auto-nack)</li> <li>Messages published with no subscribers</li> </ul> <p>The DLQ supports iteration, draining for retry, and callbacks for real-time alerting.</p>"},{"location":"concepts/#messagebus","title":"MessageBus","text":"<p>The MessageBus is a registry facade that manages multiple named channels with shared statistics. It provides a single entry point for publish, subscribe, and lifecycle operations.</p>"},{"location":"concepts/#configuration-cascade","title":"Configuration Cascade","text":"<p>TypedBus resolves configurable parameters through three tiers:</p> <pre><code>Global  \u2192  Bus  \u2192  Channel\n</code></pre> <p>Each tier inherits from the one above unless explicitly overridden. See Configuration Cascade for details.</p>"},{"location":"concepts/#concurrency-model","title":"Concurrency Model","text":"<p>TypedBus uses fiber-only concurrency powered by the <code>async</code> gem. There are no mutexes and no threads. All state is managed within a single Async reactor. Operations like backpressure waits and throttle sleeps yield the calling fiber, not the thread.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete method reference for every TypedBus class.</p>"},{"location":"api/#module","title":"Module","text":"<ul> <li><code>TypedBus</code> \u2014 top-level configuration and logger access</li> </ul>"},{"location":"api/#classes","title":"Classes","text":"<ul> <li>Configuration \u2014 global defaults and cascade resolution</li> <li>MessageBus \u2014 registry facade for named channels</li> <li>Channel \u2014 named pub/sub topic with acknowledgment tracking</li> <li>Delivery \u2014 per-subscriber message envelope</li> <li>DeliveryTracker \u2014 aggregates subscriber responses per publish</li> <li>DeadLetterQueue \u2014 collects failed deliveries</li> <li>Stats \u2014 per-channel counter map</li> </ul>"},{"location":"api/#typedbus-module","title":"TypedBus Module","text":""},{"location":"api/#typedbusconfiguration","title":"<code>TypedBus.configuration</code>","text":"<p>Returns the global <code>Configuration</code> instance.</p>"},{"location":"api/#typedbusconfigurationconfig","title":"<code>TypedBus.configuration=(config)</code>","text":"<p>Replaces the global <code>Configuration</code> instance.</p>"},{"location":"api/#typedbusconfigure-config","title":"<code>TypedBus.configure { |config| ... }</code>","text":"<p>Yields the global <code>Configuration</code> for block-style setup.</p>"},{"location":"api/#typedbusreset_configuration","title":"<code>TypedBus.reset_configuration!</code>","text":"<p>Restores factory defaults.</p>"},{"location":"api/#typedbuslogger","title":"<code>TypedBus.logger</code>","text":"<p>Shortcut for <code>TypedBus.configuration.logger</code>.</p>"},{"location":"api/#typedbusloggerlog","title":"<code>TypedBus.logger=(log)</code>","text":"<p>Shortcut for <code>TypedBus.configuration.logger = log</code>.</p>"},{"location":"api/channel/","title":"Channel","text":"<p><code>TypedBus::Channel</code></p> <p>A named, typed pub/sub channel with explicit acknowledgment tracking.</p>"},{"location":"api/channel/#constructor","title":"Constructor","text":""},{"location":"api/channel/#channelnewname-type-timeout-max_pending-stats-throttle","title":"<code>Channel.new(name, type:, timeout:, max_pending:, stats:, throttle:)</code>","text":"Parameter Default Description <code>name</code> required <code>Symbol</code> channel name <code>type</code> <code>nil</code> Optional class constraint for messages <code>timeout</code> <code>30</code> Seconds before delivery auto-nacks <code>max_pending</code> <code>nil</code> Backpressure limit; <code>nil</code> = unbounded <code>stats</code> <code>nil</code> Optional <code>Stats</code> instance for counters <code>throttle</code> <code>0.0</code> Capacity ratio where backoff begins <pre><code>channel = TypedBus::Channel.new(:orders,\n  type: Order,\n  timeout: 10,\n  max_pending: 100,\n  throttle: 0.5\n)\n</code></pre> <p>Note</p> <p>When using channels via <code>MessageBus</code>, these values are resolved through the configuration cascade. You don't normally construct channels directly with all parameters.</p>"},{"location":"api/channel/#attributes","title":"Attributes","text":""},{"location":"api/channel/#name-symbol","title":"<code>name</code> \u2192 <code>Symbol</code>","text":"<p>Channel name.</p>"},{"location":"api/channel/#type-class-nil","title":"<code>type</code> \u2192 <code>Class</code>, <code>nil</code>","text":"<p>Type constraint, or <code>nil</code> for untyped channels.</p>"},{"location":"api/channel/#dead_letter_queue-deadletterqueue","title":"<code>dead_letter_queue</code> \u2192 <code>DeadLetterQueue</code>","text":"<p>The channel's dead letter queue.</p>"},{"location":"api/channel/#pubsub","title":"Pub/Sub","text":""},{"location":"api/channel/#publishmessage-deliverytracker-nil","title":"<code>publish(message)</code> \u2192 <code>DeliveryTracker</code>, <code>nil</code>","text":"<p>Publish a message to all current subscribers.</p> <ul> <li>Blocks the calling fiber if bounded and at capacity</li> <li>Applies throttle delay if configured</li> <li>Returns <code>nil</code> if no subscribers (message goes to DLQ)</li> </ul> <p>Raises: <code>ArgumentError</code> for type mismatches. <code>RuntimeError</code> if closed.</p>"},{"location":"api/channel/#subscribeblock-integer","title":"<code>subscribe(&amp;block)</code> \u2192 <code>Integer</code>","text":"<p>Subscribe to messages. Returns the subscriber ID.</p> <p>Raises: <code>RuntimeError</code> if closed.</p>"},{"location":"api/channel/#unsubscribeid_or_block","title":"<code>unsubscribe(id_or_block)</code>","text":"<p>Remove a subscriber by integer ID or block reference.</p>"},{"location":"api/channel/#query","title":"Query","text":""},{"location":"api/channel/#subscriber_count-integer","title":"<code>subscriber_count</code> \u2192 <code>Integer</code>","text":"<p>Number of active subscribers.</p>"},{"location":"api/channel/#pending_count-integer","title":"<code>pending_count</code> \u2192 <code>Integer</code>","text":"<p>Number of unresolved delivery trackers.</p>"},{"location":"api/channel/#pending-boolean","title":"<code>pending?</code> \u2192 <code>Boolean</code>","text":"<p>True when there are unresolved deliveries.</p>"},{"location":"api/channel/#closed-boolean","title":"<code>closed?</code> \u2192 <code>Boolean</code>","text":"<p>True if the channel has been closed.</p>"},{"location":"api/channel/#lifecycle","title":"Lifecycle","text":""},{"location":"api/channel/#close","title":"<code>close</code>","text":"<p>Stop accepting new publishes and subscribes. Pending deliveries are force-NACKed and routed to the DLQ.</p>"},{"location":"api/channel/#clear","title":"<code>clear!</code>","text":"<p>Hard reset: cancel all timeout tasks, discard pending state, clear DLQ. Does not mark the channel as closed.</p>"},{"location":"api/configuration/","title":"Configuration","text":"<p><code>TypedBus::Configuration</code></p> <p>Holds configurable defaults for the message bus system. Supports three-tier cascade: Global \u2192 Bus \u2192 Channel.</p>"},{"location":"api/configuration/#attributes","title":"Attributes","text":"Attribute Type Default Description <code>timeout</code> <code>Numeric</code> <code>30</code> Delivery ACK deadline in seconds <code>max_pending</code> <code>Integer</code>, <code>nil</code> <code>nil</code> Backpressure limit; <code>nil</code> = unbounded <code>throttle</code> <code>Float</code> <code>0.0</code> Remaining-capacity ratio where backoff begins <code>logger</code> <code>Logger</code>, <code>nil</code> <code>nil</code> Ruby Logger instance <code>log_level</code> <code>Integer</code> <code>Logger::INFO</code> Log level applied to the logger"},{"location":"api/configuration/#constructor","title":"Constructor","text":""},{"location":"api/configuration/#configurationnew","title":"<code>Configuration.new</code>","text":"<p>Creates a new Configuration with factory defaults.</p>"},{"location":"api/configuration/#methods","title":"Methods","text":""},{"location":"api/configuration/#timeout-max_pending-throttle","title":"<code>timeout=</code>, <code>max_pending=</code>, <code>throttle=</code>","text":"<p>Standard setters for cascade parameters.</p>"},{"location":"api/configuration/#loggerlog","title":"<code>logger=(log)</code>","text":"<p>Sets the logger and applies the current <code>log_level</code> to it.</p> <pre><code>config.logger = Logger.new($stdout)\n# config.logger.level is now config.log_level\n</code></pre>"},{"location":"api/configuration/#log_levellevel","title":"<code>log_level=(level)</code>","text":"<p>Sets the log level and applies it to the current logger (if present).</p> <pre><code>config.log_level = Logger::DEBUG\n# config.logger.level is now Logger::DEBUG (if logger is set)\n</code></pre>"},{"location":"api/configuration/#resolvetimeout-max_pending-throttle","title":"<code>resolve(timeout:, max_pending:, throttle:)</code>","text":"<p>Merges overrides on top of this configuration's values. Parameters set to <code>:use_default</code> inherit from this config.</p> <p>Parameters:</p> Parameter Default Description <code>timeout</code> <code>:use_default</code> Delivery ACK deadline <code>max_pending</code> <code>:use_default</code> Backpressure limit <code>throttle</code> <code>:use_default</code> Capacity ratio for adaptive backoff <p>Returns: <code>Hash</code> with resolved <code>:timeout</code>, <code>:max_pending</code>, and <code>:throttle</code> values.</p> <pre><code>config = TypedBus::Configuration.new\nconfig.timeout = 60\n\nconfig.resolve(timeout: 10)\n# =&gt; { timeout: 10, max_pending: nil, throttle: 0.0 }\n\nconfig.resolve\n# =&gt; { timeout: 60, max_pending: nil, throttle: 0.0 }\n</code></pre>"},{"location":"api/configuration/#dup","title":"<code>dup</code>","text":"<p>Returns an independent shallow copy. The logger is intentionally shared (same Logger instance); all other fields are independent.</p>"},{"location":"api/configuration/#constants","title":"Constants","text":""},{"location":"api/configuration/#defaults","title":"<code>DEFAULTS</code>","text":"<p>Frozen hash of factory defaults:</p> <pre><code>{\n  timeout: 30,\n  max_pending: nil,\n  throttle: 0.0,\n  logger: nil,\n  log_level: Logger::INFO\n}\n</code></pre>"},{"location":"api/dead-letter-queue/","title":"DeadLetterQueue","text":"<p><code>TypedBus::DeadLetterQueue</code></p> <p>Stores deliveries that failed \u2014 either explicitly NACKed or timed out. Each Channel owns a DLQ. Includes <code>Enumerable</code>.</p>"},{"location":"api/dead-letter-queue/#constructor","title":"Constructor","text":""},{"location":"api/dead-letter-queue/#deadletterqueuenewon_dead_letter","title":"<code>DeadLetterQueue.new(&amp;on_dead_letter)</code>","text":"<p>Optionally accepts a block that fires on each <code>push</code>.</p>"},{"location":"api/dead-letter-queue/#methods","title":"Methods","text":""},{"location":"api/dead-letter-queue/#pushdelivery","title":"<code>push(delivery)</code>","text":"<p>Add a failed delivery.</p>"},{"location":"api/dead-letter-queue/#size-integer","title":"<code>size</code> \u2192 <code>Integer</code>","text":"<p>Number of entries.</p>"},{"location":"api/dead-letter-queue/#empty-boolean","title":"<code>empty?</code> \u2192 <code>Boolean</code>","text":"<p>True if no entries.</p>"},{"location":"api/dead-letter-queue/#eachblock","title":"<code>each(&amp;block)</code>","text":"<p>Iterate over dead letters without removing them.</p>"},{"location":"api/dead-letter-queue/#drain-delivery-arraydelivery","title":"<code>drain { |delivery| ... }</code> \u2192 <code>Array&lt;Delivery&gt;</code>","text":"<p>Yield each dead letter and remove it from the queue. Returns the drained entries. Without a block, just removes and returns them.</p>"},{"location":"api/dead-letter-queue/#clear","title":"<code>clear!</code>","text":"<p>Discard all entries.</p>"},{"location":"api/dead-letter-queue/#on_dead_letter-delivery","title":"<code>on_dead_letter { |delivery| ... }</code>","text":"<p>Register or replace the callback fired when entries arrive.</p>"},{"location":"api/dead-letter-queue/#enumerable","title":"Enumerable","text":"<p><code>DeadLetterQueue</code> includes <code>Enumerable</code>, so you can use <code>map</code>, <code>select</code>, <code>count</code>, <code>any?</code>, etc.:</p> <pre><code>dlq = channel.dead_letter_queue\n\ntimed_out = dlq.count(&amp;:timed_out?)\nmessages  = dlq.map(&amp;:message)\n</code></pre>"},{"location":"api/delivery-tracker/","title":"DeliveryTracker","text":"<p><code>TypedBus::DeliveryTracker</code></p> <p>Tracks the delivery state of a single published message across N subscribers. Created per <code>publish</code> call.</p>"},{"location":"api/delivery-tracker/#constructor","title":"Constructor","text":""},{"location":"api/delivery-tracker/#deliverytrackernewmessage-channel_name-subscriber_ids","title":"<code>DeliveryTracker.new(message, channel_name:, subscriber_ids:)</code>","text":"Parameter Default Description <code>message</code> required The published payload <code>channel_name</code> required Originating channel name <code>subscriber_ids</code> required <code>Array&lt;Integer&gt;</code> of subscriber IDs <p>Note</p> <p>Trackers are created internally by <code>Channel#publish</code>. You don't normally construct them directly.</p>"},{"location":"api/delivery-tracker/#attributes","title":"Attributes","text":""},{"location":"api/delivery-tracker/#message-object","title":"<code>message</code> \u2192 <code>Object</code>","text":"<p>The published payload.</p>"},{"location":"api/delivery-tracker/#channel_name-symbol","title":"<code>channel_name</code> \u2192 <code>Symbol</code>","text":"<p>The originating channel.</p>"},{"location":"api/delivery-tracker/#recording-responses","title":"Recording Responses","text":""},{"location":"api/delivery-tracker/#acksubscriber_id","title":"<code>ack(subscriber_id)</code>","text":"<p>Record an ACK from a subscriber. Checks for resolution after recording.</p>"},{"location":"api/delivery-tracker/#nacksubscriber_id","title":"<code>nack(subscriber_id)</code>","text":"<p>Record a NACK from a subscriber. Fires the <code>on_dead_letter</code> callback. Checks for resolution after recording.</p>"},{"location":"api/delivery-tracker/#state","title":"State","text":""},{"location":"api/delivery-tracker/#fully_delivered-boolean","title":"<code>fully_delivered?</code> \u2192 <code>Boolean</code>","text":"<p>True when every subscriber has ACKed.</p>"},{"location":"api/delivery-tracker/#fully_resolved-boolean","title":"<code>fully_resolved?</code> \u2192 <code>Boolean</code>","text":"<p>True when all subscribers have responded (acked or nacked).</p>"},{"location":"api/delivery-tracker/#pending_count-integer","title":"<code>pending_count</code> \u2192 <code>Integer</code>","text":"<p>Number of subscribers still pending.</p>"},{"location":"api/delivery-tracker/#callbacks","title":"Callbacks","text":""},{"location":"api/delivery-tracker/#on_complete","title":"<code>on_complete { ... }</code>","text":"<p>Called when all subscribers have resolved and every one ACKed (successful delivery).</p>"},{"location":"api/delivery-tracker/#on_resolved","title":"<code>on_resolved { ... }</code>","text":"<p>Called when all subscribers have resolved, regardless of outcome. Used for cleanup (e.g., removing from pending map, signaling backpressure).</p>"},{"location":"api/delivery-tracker/#on_dead_letter-subscriber_id","title":"<code>on_dead_letter { |subscriber_id| ... }</code>","text":"<p>Called for each NACK, receiving the subscriber ID.</p>"},{"location":"api/delivery/","title":"Delivery","text":"<p><code>TypedBus::Delivery</code></p> <p>Envelope wrapping a message delivered to a single subscriber. Each subscriber receives its own Delivery instance for the same message.</p>"},{"location":"api/delivery/#constructor","title":"Constructor","text":""},{"location":"api/delivery/#deliverynewmessage-channel_name-subscriber_id-timeout-on_ack-on_nack","title":"<code>Delivery.new(message, channel_name:, subscriber_id:, timeout:, on_ack:, on_nack:)</code>","text":"Parameter Default Description <code>message</code> required The published payload <code>channel_name</code> required Originating channel name <code>subscriber_id</code> required Target subscriber's ID <code>timeout</code> <code>nil</code> Seconds before auto-nack; <code>nil</code> = no timeout <code>on_ack</code> <code>nil</code> Callback proc called with subscriber_id on ack <code>on_nack</code> <code>nil</code> Callback proc called with subscriber_id on nack <p>Note</p> <p>Deliveries are created internally by <code>Channel#publish</code>. You don't normally construct them directly.</p>"},{"location":"api/delivery/#attributes","title":"Attributes","text":""},{"location":"api/delivery/#message-object","title":"<code>message</code> \u2192 <code>Object</code>","text":"<p>The published payload.</p>"},{"location":"api/delivery/#channel_name-symbol","title":"<code>channel_name</code> \u2192 <code>Symbol</code>","text":"<p>The originating channel.</p>"},{"location":"api/delivery/#subscriber_id-integer","title":"<code>subscriber_id</code> \u2192 <code>Integer</code>","text":"<p>The target subscriber's ID.</p>"},{"location":"api/delivery/#resolution","title":"Resolution","text":""},{"location":"api/delivery/#ack","title":"<code>ack!</code>","text":"<p>Mark as successfully processed. Cancels the timeout timer.</p> <p>Raises: <code>RuntimeError</code> if already resolved.</p>"},{"location":"api/delivery/#nack","title":"<code>nack!</code>","text":"<p>Mark as failed. Routes to the dead letter queue. Cancels the timeout timer.</p> <p>Raises: <code>RuntimeError</code> if already resolved.</p>"},{"location":"api/delivery/#state","title":"State","text":""},{"location":"api/delivery/#pending-boolean","title":"<code>pending?</code> \u2192 <code>Boolean</code>","text":"<p>Not yet resolved.</p>"},{"location":"api/delivery/#acked-boolean","title":"<code>acked?</code> \u2192 <code>Boolean</code>","text":"<p>Successfully acknowledged.</p>"},{"location":"api/delivery/#nacked-boolean","title":"<code>nacked?</code> \u2192 <code>Boolean</code>","text":"<p>Explicitly rejected or timed out.</p>"},{"location":"api/delivery/#timed_out-boolean","title":"<code>timed_out?</code> \u2192 <code>Boolean</code>","text":"<p>True if the nack was caused by timeout (as opposed to explicit <code>nack!</code>).</p>"},{"location":"api/delivery/#timeout","title":"Timeout","text":""},{"location":"api/delivery/#cancel_timeout","title":"<code>cancel_timeout</code>","text":"<p>Cancel the timeout timer without resolving the delivery. Used internally during <code>close</code> and <code>clear!</code>.</p>"},{"location":"api/message-bus/","title":"MessageBus","text":"<p><code>TypedBus::MessageBus</code></p> <p>Registry facade for named, typed pub/sub channels with shared statistics.</p>"},{"location":"api/message-bus/#constructor","title":"Constructor","text":""},{"location":"api/message-bus/#messagebusnewtimeout-max_pending-throttle","title":"<code>MessageBus.new(timeout:, max_pending:, throttle:)</code>","text":"<p>Creates a new bus. All parameters default to <code>:use_default</code>, inheriting from the global configuration.</p> Parameter Default Description <code>timeout</code> <code>:use_default</code> Delivery ACK deadline for channels <code>max_pending</code> <code>:use_default</code> Backpressure limit for channels <code>throttle</code> <code>:use_default</code> Throttle threshold for channels <pre><code>bus = TypedBus::MessageBus.new(timeout: 10, throttle: 0.5)\n</code></pre>"},{"location":"api/message-bus/#attributes","title":"Attributes","text":""},{"location":"api/message-bus/#stats-stats","title":"<code>stats</code> \u2192 <code>Stats</code>","text":"<p>The shared Stats instance for all channels on this bus.</p>"},{"location":"api/message-bus/#config-configuration","title":"<code>config</code> \u2192 <code>Configuration</code>","text":"<p>The bus-level Configuration (independent copy of global config with overrides applied).</p>"},{"location":"api/message-bus/#channel-management","title":"Channel Management","text":""},{"location":"api/message-bus/#add_channelname-type-timeout-max_pending-throttle-channel","title":"<code>add_channel(name, type:, timeout:, max_pending:, throttle:)</code> \u2192 <code>Channel</code>","text":"<p>Register a named channel. Parameters default to <code>:use_default</code>, inheriting from the bus config.</p> Parameter Default Description <code>name</code> required <code>Symbol</code> channel name <code>type</code> <code>nil</code> Optional type constraint <code>timeout</code> <code>:use_default</code> Delivery ACK deadline in seconds <code>max_pending</code> <code>:use_default</code> Backpressure limit <code>throttle</code> <code>:use_default</code> Throttle threshold"},{"location":"api/message-bus/#remove_channelname","title":"<code>remove_channel(name)</code>","text":"<p>Close and remove a channel. No-op for unknown channels.</p>"},{"location":"api/message-bus/#channelname-boolean","title":"<code>channel?(name)</code> \u2192 <code>Boolean</code>","text":"<p>Check if a channel exists.</p>"},{"location":"api/message-bus/#channel_names-arraysymbol","title":"<code>channel_names</code> \u2192 <code>Array&lt;Symbol&gt;</code>","text":"<p>List registered channel names.</p>"},{"location":"api/message-bus/#pubsub","title":"Pub/Sub","text":""},{"location":"api/message-bus/#publishchannel_name-message-deliverytracker-nil","title":"<code>publish(channel_name, message)</code> \u2192 <code>DeliveryTracker</code>, <code>nil</code>","text":"<p>Publish a message to a named channel. Returns the <code>DeliveryTracker</code> or <code>nil</code> if no subscribers.</p> <p>Raises: <code>ArgumentError</code> for unknown channels, type mismatches. <code>RuntimeError</code> for closed channels.</p>"},{"location":"api/message-bus/#subscribechannel_name-block-integer","title":"<code>subscribe(channel_name, &amp;block)</code> \u2192 <code>Integer</code>","text":"<p>Subscribe to a named channel. Returns the subscriber ID.</p>"},{"location":"api/message-bus/#unsubscribechannel_name-id_or_block","title":"<code>unsubscribe(channel_name, id_or_block)</code>","text":"<p>Remove a subscriber by ID or block reference.</p>"},{"location":"api/message-bus/#query","title":"Query","text":""},{"location":"api/message-bus/#pendingchannel_name-boolean","title":"<code>pending?(channel_name)</code> \u2192 <code>Boolean</code>","text":"<p>Check if a channel has unresolved deliveries.</p>"},{"location":"api/message-bus/#pending_countchannel_name-integer","title":"<code>pending_count(channel_name)</code> \u2192 <code>Integer</code>","text":"<p>Number of unresolved deliveries.</p>"},{"location":"api/message-bus/#dead_letterschannel_name-deadletterqueue","title":"<code>dead_letters(channel_name)</code> \u2192 <code>DeadLetterQueue</code>","text":"<p>Access a channel's dead letter queue.</p>"},{"location":"api/message-bus/#lifecycle","title":"Lifecycle","text":""},{"location":"api/message-bus/#closechannel_name","title":"<code>close(channel_name)</code>","text":"<p>Close a specific channel. Pending deliveries are force-NACKed.</p>"},{"location":"api/message-bus/#close_all","title":"<code>close_all</code>","text":"<p>Close all channels.</p>"},{"location":"api/message-bus/#clear","title":"<code>clear!</code>","text":"<p>Close all channels, clear DLQs, and reset stats.</p>"},{"location":"api/stats/","title":"Stats","text":"<p><code>TypedBus::Stats</code></p> <p>Simple counter map for message bus activity. Fiber-safe \u2014 no mutex needed within a single Async reactor.</p>"},{"location":"api/stats/#constructor","title":"Constructor","text":""},{"location":"api/stats/#statsnew","title":"<code>Stats.new</code>","text":"<p>Creates a new Stats instance with no counters.</p>"},{"location":"api/stats/#methods","title":"Methods","text":""},{"location":"api/stats/#incrementkey-integer","title":"<code>increment(key)</code> \u2192 <code>Integer</code>","text":"<p>Increment a named counter. Returns the new value.</p> <pre><code>stats.increment(:orders_published)  # =&gt; 1\nstats.increment(:orders_published)  # =&gt; 2\n</code></pre>"},{"location":"api/stats/#key-integer","title":"<code>[](key)</code> \u2192 <code>Integer</code>","text":"<p>Read a counter value. Returns <code>0</code> for unknown keys.</p> <pre><code>stats[:orders_published]  # =&gt; 2\nstats[:nonexistent]       # =&gt; 0\n</code></pre>"},{"location":"api/stats/#reset","title":"<code>reset!</code>","text":"<p>Zero all counters. Keys are preserved, values set to <code>0</code>.</p>"},{"location":"api/stats/#to_h-hashsymbol-integer","title":"<code>to_h</code> \u2192 <code>Hash&lt;Symbol, Integer&gt;</code>","text":"<p>Return a snapshot (dup) of all counters.</p> <pre><code>stats.to_h\n# =&gt; { orders_published: 2, orders_delivered: 1 }\n</code></pre>"},{"location":"api/stats/#attributes","title":"Attributes","text":""},{"location":"api/stats/#data-hash","title":"<code>data</code> \u2192 <code>Hash</code>","text":"<p>Direct access to the underlying counter hash. Prefer <code>[]</code> and <code>to_h</code> for read access.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>TypedBus is a small library with a clear internal structure. This section explains the core design decisions.</p> <ul> <li>Publish Flow \u2014 what happens when you call <code>publish</code></li> <li>Concurrency Model \u2014 fiber-only design with Async</li> <li>Configuration Cascade \u2014 three-tier parameter resolution</li> </ul>"},{"location":"architecture/concurrency-model/","title":"Concurrency Model","text":"<p>TypedBus uses fiber-only concurrency powered by the async gem. There are no mutexes and no threads anywhere in the library.</p>"},{"location":"architecture/concurrency-model/#single-reactor","title":"Single Reactor","text":"<p>All TypedBus state lives within a single Async reactor. The <code>Async { }</code> block creates the reactor, and all publish/subscribe operations run as fibers within it.</p> <pre><code>Async do\n  bus.publish(:events, \"hello\")   # runs as a fiber\n  bus.publish(:events, \"world\")   # runs as a fiber\nend\n</code></pre>"},{"location":"architecture/concurrency-model/#why-fibers","title":"Why Fibers?","text":"<p>Ruby fibers provide cooperative concurrency:</p> <ul> <li>No race conditions \u2014 only one fiber runs at a time within a reactor</li> <li>No locks needed \u2014 shared state is safe without mutexes</li> <li>Yielding, not blocking \u2014 <code>sleep</code>, backpressure waits, and throttle delays yield the fiber, allowing other fibers to progress</li> </ul>"},{"location":"architecture/concurrency-model/#where-async-tasks-are-created","title":"Where Async Tasks Are Created","text":"<p>TypedBus creates Async tasks in two places:</p> <ol> <li> <p>Subscriber dispatch \u2014 each subscriber's block runs in its own <code>Async</code> task when a message is published. This allows multiple subscribers to process concurrently.</p> </li> <li> <p>Delivery timeout \u2014 each Delivery starts an <code>Async</code> task that sleeps for the timeout duration and then auto-nacks if the delivery is still pending.</p> </li> </ol>"},{"location":"architecture/concurrency-model/#implications","title":"Implications","text":"<ul> <li><code>publish</code> must be called inside an <code>Async { }</code> block (or within an existing reactor)</li> <li>Subscriber blocks execute concurrently with each other</li> <li>A subscriber that never returns will keep its Delivery pending until the timeout fires</li> <li>Backpressure (<code>wait_for_capacity</code>) blocks the publishing fiber \u2014 other fibers continue running</li> <li>Throttle delays (<code>sleep</code>) yield the publishing fiber \u2014 other fibers continue running</li> </ul>"},{"location":"architecture/configuration-cascade/","title":"Configuration Cascade","text":"<p>TypedBus resolves configurable parameters through three tiers:</p> <pre><code>Global  \u2192  Bus  \u2192  Channel\n</code></pre> <p>Each tier inherits from the one above unless explicitly overridden.</p>"},{"location":"architecture/configuration-cascade/#how-it-works","title":"How It Works","text":"<pre><code>flowchart LR\n    G[Global Config] --&gt;|dup| B[Bus Config]\n    B --&gt;|resolve| C[Channel Values]</code></pre> <ol> <li>Global \u2014 <code>TypedBus.configure { |c| ... }</code> sets defaults for all buses. Stored as a singleton <code>Configuration</code> instance.</li> <li>Bus \u2014 <code>MessageBus.new(timeout: 10)</code> creates a <code>dup</code> of the global config, then applies any explicit overrides. Each bus holds its own independent <code>Configuration</code>.</li> <li>Channel \u2014 <code>bus.add_channel(:name, timeout: 5)</code> resolves values via the bus's config. The channel receives fully resolved scalars \u2014 it has no awareness of the cascade.</li> </ol>"},{"location":"architecture/configuration-cascade/#the-use_default-sentinel","title":"The <code>:use_default</code> Sentinel","text":"<p>The sentinel value <code>:use_default</code> means \"inherit from the tier above.\" It is the default for all cascade parameters at both bus and channel levels.</p> <p>This sentinel is necessary to distinguish \"not provided\" from an explicit <code>nil</code>. For <code>max_pending</code>, <code>nil</code> means \"unbounded\" \u2014 a meaningful value that must be distinguishable from \"use whatever the parent says.\"</p> <pre><code># These are different:\nbus.add_channel(:a)                    # max_pending inherited from bus\nbus.add_channel(:b, max_pending: nil)  # max_pending explicitly unbounded\n</code></pre>"},{"location":"architecture/configuration-cascade/#cascaded-parameters","title":"Cascaded Parameters","text":"Parameter Default Cascades? <code>timeout</code> <code>30</code> Global \u2192 Bus \u2192 Channel <code>max_pending</code> <code>nil</code> Global \u2192 Bus \u2192 Channel <code>throttle</code> <code>0.0</code> Global \u2192 Bus \u2192 Channel <code>logger</code> <code>nil</code> Global only <code>log_level</code> <code>Logger::INFO</code> Global only <p><code>logger</code> and <code>log_level</code> are global-only because the logger is a shared resource. All buses and channels read the logger via <code>TypedBus.logger</code>.</p>"},{"location":"architecture/configuration-cascade/#isolation","title":"Isolation","text":"<p>Each bus gets an independent config snapshot via <code>dup</code>. Changing a bus's config does not affect the global or other buses:</p> <pre><code>TypedBus.configure { |c| c.timeout = 60 }\n\nbus_a = TypedBus::MessageBus.new(timeout: 10)\nbus_b = TypedBus::MessageBus.new(timeout: 99)\n\nbus_a.config.timeout  # =&gt; 10\nbus_b.config.timeout  # =&gt; 99\nTypedBus.configuration.timeout  # =&gt; 60 (unchanged)\n</code></pre>"},{"location":"architecture/configuration-cascade/#implementation","title":"Implementation","text":"<p>The cascade logic lives in <code>Configuration#resolve</code>:</p> <pre><code>def resolve(timeout: :use_default, max_pending: :use_default, throttle: :use_default)\n  {\n    timeout:     timeout     == :use_default ? @timeout     : timeout,\n    max_pending: max_pending == :use_default ? @max_pending : max_pending,\n    throttle:    throttle    == :use_default ? @throttle    : throttle\n  }\nend\n</code></pre> <p><code>MessageBus#initialize</code> calls <code>resolve</code> on the global config. <code>MessageBus#add_channel</code> calls <code>resolve</code> on the bus config. The channel receives the final resolved values.</p>"},{"location":"architecture/publish-flow/","title":"Publish Flow","text":"<p>When you call <code>channel.publish(message)</code>, the following steps execute in order:</p> <pre><code>flowchart TD\n    A[publish called] --&gt; B{Channel closed?}\n    B -- yes --&gt; ERR[raise RuntimeError]\n    B -- no --&gt; C[Type check]\n    C --&gt; D{Throttle enabled?}\n    D -- yes --&gt; E[Apply throttle delay]\n    D -- no --&gt; F{Bounded channel?}\n    E --&gt; F\n    F -- yes --&gt; G[Wait for capacity]\n    F -- no --&gt; H{Subscribers?}\n    G --&gt; H\n    H -- none --&gt; I[Route to DLQ]\n    H -- 1+ --&gt; J[Create DeliveryTracker]\n    J --&gt; K[Fan out Delivery per subscriber]\n    K --&gt; L[Each subscriber runs in Async task]\n    L --&gt; M{ack! or nack!}\n    M -- ack --&gt; N[Tracker records ack]\n    M -- nack --&gt; O[Tracker records nack \u2192 DLQ]\n    M -- timeout --&gt; P[Auto-nack \u2192 DLQ]\n    N --&gt; Q{All resolved?}\n    O --&gt; Q\n    P --&gt; Q\n    Q -- yes, all acked --&gt; R[on_complete \u2192 delivered stat]\n    Q -- yes, some nacked --&gt; S[on_resolved \u2192 cleanup]</code></pre>"},{"location":"architecture/publish-flow/#step-by-step","title":"Step-by-Step","text":""},{"location":"architecture/publish-flow/#1-guard-closed-channel","title":"1. Guard: Closed Channel","text":"<p>If the channel is closed, <code>publish</code> raises <code>RuntimeError</code>. No message is delivered.</p>"},{"location":"architecture/publish-flow/#2-type-check","title":"2. Type Check","text":"<p>If the channel has a <code>type:</code> constraint, the message's class is verified with <code>is_a?</code>. A mismatch raises <code>ArgumentError</code>.</p>"},{"location":"architecture/publish-flow/#3-throttle","title":"3. Throttle","text":"<p>If <code>throttle</code> is configured and the channel is bounded, the remaining capacity ratio is checked. Below the threshold, the publisher sleeps for <code>1 / (max_pending * remaining_ratio)</code> seconds \u2014 an asymptotic delay that approaches infinity as remaining capacity approaches zero.</p>"},{"location":"architecture/publish-flow/#4-backpressure","title":"4. Backpressure","text":"<p>If the channel is bounded (<code>max_pending</code> is set) and the pending delivery count has reached the limit, the publishing fiber blocks on an <code>Async::Condition</code> until a subscriber ACKs and frees a slot.</p>"},{"location":"architecture/publish-flow/#5-fan-out","title":"5. Fan-Out","text":"<p>A <code>DeliveryTracker</code> is created for this message, tracking the set of current subscriber IDs. Each subscriber receives its own <code>Delivery</code> envelope in a separate <code>Async</code> task.</p>"},{"location":"architecture/publish-flow/#6-resolution","title":"6. Resolution","text":"<p>Each subscriber must call <code>ack!</code> or <code>nack!</code> on its Delivery. If neither is called before the timeout, the delivery auto-nacks. The tracker aggregates responses:</p> <ul> <li>All acked \u2014 the <code>on_complete</code> callback fires, incrementing the <code>:delivered</code> stat.</li> <li>Any nacked \u2014 the <code>on_resolved</code> callback fires for cleanup. NACKed deliveries are pushed to the dead letter queue.</li> </ul>"},{"location":"architecture/publish-flow/#7-backpressure-release","title":"7. Backpressure Release","text":"<p>When a tracker resolves, the pending delivery is removed and <code>@backpressure.signal</code> wakes any blocked publisher fiber.</p>"},{"location":"architecture/publish-flow/#no-subscriber-path","title":"No-Subscriber Path","text":"<p>If there are no subscribers when <code>publish</code> is called, the message is wrapped in a Delivery, immediately NACKed, and pushed to the dead letter queue. The <code>:nacked</code> and <code>:dead_lettered</code> stats are incremented.</p>"},{"location":"examples/","title":"Examples","text":"<p>TypedBus ships with runnable examples in the <code>examples/</code> directory. Run any example from the project root:</p> <pre><code>bundle exec ruby examples/01_basic_usage.rb\n</code></pre>"},{"location":"examples/#demo-index","title":"Demo Index","text":"# File Description 00 <code>00_config.rb</code> Three-tier configuration cascade. Global defaults, bus-level overrides, per-channel overrides, inheritance, and <code>reset_configuration!</code>. 01 <code>01_basic_usage.rb</code> Basic pub/sub with explicit acknowledgment. One channel, one subscriber, <code>ack!</code> after each message. 02 <code>02_typed_channels.rb</code> Type-constrained channels. Publishing the wrong type raises <code>ArgumentError</code> at the publish site. 03 <code>03_multiple_subscribers.rb</code> Fan-out delivery. Every subscriber gets its own <code>Delivery</code>; a message is only \"delivered\" when all subscribers ACK. Shows <code>DeliveryTracker</code> state queries. 04 <code>04_nack_and_dead_letters.rb</code> Explicit rejection with <code>nack!</code>. Rejected deliveries route to the dead letter queue. Shows DLQ iteration and <code>drain</code> for retry. 05 <code>05_delivery_timeout.rb</code> Delivery deadlines. Subscribers that don't respond within the timeout are auto-NACKed. Shows <code>timed_out?</code> flag. 06 <code>06_backpressure.rb</code> Bounded channels with <code>max_pending</code>. The publisher fiber blocks when the limit is reached and resumes as subscribers ACK. 07 <code>07_message_bus.rb</code> <code>MessageBus</code> registry facade. Manages multiple typed channels, aggregates stats, single entry point for publish/subscribe. 08 <code>08_error_handling.rb</code> Edge cases: subscriber exceptions (auto-nack), no subscribers (DLQ), unsubscribe mid-stream, close force-nacks, publishing to closed channel. 09 <code>09_stats_and_monitoring.rb</code> Per-channel stat counters. Combines DLQ callbacks with stats for real-time alerting. Shows <code>reset!</code>. 10 <code>10_concurrent_pipeline.rb</code> Multi-stage event pipeline: ingest, validate, process. Typed messages, backpressure, timeouts, DLQ monitoring, graceful shutdown. 11 <code>11_logging_basic.rb</code> Structured logging via <code>TypedBus.logger</code>. Lifecycle log output for channel creation, subscriber registration, publish, delivery, ack, tracker resolution. 12 <code>12_logging_failures.rb</code> Failure-path logging: explicit nacks, delivery timeouts, no-subscriber dead-lettering, DLQ drain. Colorized output. 13 <code>13_logging_backpressure.rb</code> Backpressure logging. DEBUG-level messages as the publisher fiber blocks and resumes while a slow subscriber drains a bounded channel. 14 <code>14_adaptive_throttling.rb</code> Adaptive rate limiting with <code>throttle: Float</code>. Asymptotic backoff as a bounded channel fills, bus-level throttle defaults with per-channel overrides."},{"location":"examples/#running-all-examples","title":"Running All Examples","text":"<pre><code>for f in examples/*.rb; do\n  echo \"=== $f ===\"\n  bundle exec ruby \"$f\"\n  echo\ndone\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section covers installation, a quick start tutorial, and configuration basics to get you productive with TypedBus.</p> <ul> <li>Installation \u2014 add TypedBus to your project</li> <li>Quick Start \u2014 publish and subscribe in under 20 lines</li> <li>Configuration \u2014 set global, bus, and channel defaults</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>TypedBus resolves parameters through a three-tier cascade: Global \u2192 Bus \u2192 Channel. Each tier inherits from the one above unless explicitly overridden.</p>"},{"location":"getting-started/configuration/#parameters","title":"Parameters","text":"Parameter Default Description <code>timeout</code> <code>30</code> Delivery ACK deadline in seconds <code>max_pending</code> <code>nil</code> Backpressure limit; <code>nil</code> = unbounded <code>throttle</code> <code>0.0</code> Remaining-capacity ratio where backoff begins; <code>0.0</code> = disabled <code>logger</code> <code>nil</code> Ruby Logger instance (global-only) <code>log_level</code> <code>Logger::INFO</code> Log level applied to the logger (global-only)"},{"location":"getting-started/configuration/#global-defaults","title":"Global Defaults","text":"<p>Set defaults that apply to every bus and channel:</p> <pre><code>TypedBus.configure do |config|\n  config.timeout     = 60\n  config.max_pending = 500\n  config.throttle    = 0.5\n  config.logger      = Logger.new($stdout)\n  config.log_level   = Logger::DEBUG\nend\n</code></pre>"},{"location":"getting-started/configuration/#bus-level-overrides","title":"Bus-Level Overrides","text":"<p>Pass parameters to <code>MessageBus.new</code> to override globals for this bus:</p> <pre><code># Inherits global max_pending and throttle, overrides timeout\nbus = TypedBus::MessageBus.new(timeout: 10)\n</code></pre> <p>Each bus gets an independent config snapshot. Mutating one does not affect the global or other buses.</p>"},{"location":"getting-started/configuration/#channel-level-overrides","title":"Channel-Level Overrides","text":"<p>Pass parameters to <code>add_channel</code> to override the bus defaults for this channel:</p> <pre><code># Inherits bus timeout, overrides max_pending\nbus.add_channel(:alerts, max_pending: 50)\n</code></pre>"},{"location":"getting-started/configuration/#cascade-example","title":"Cascade Example","text":"<pre><code>TypedBus.configure do |config|\n  config.timeout     = 60    # global default\n  config.max_pending = 500\nend\n\nbus = TypedBus::MessageBus.new(timeout: 30)  # bus overrides timeout\n\nbus.add_channel(:orders)              # timeout=30, max_pending=500\nbus.add_channel(:alerts, timeout: 5)  # timeout=5,  max_pending=500\n</code></pre>"},{"location":"getting-started/configuration/#logger-shortcuts","title":"Logger Shortcuts","text":"<pre><code># These are equivalent:\nTypedBus.configure { |c| c.logger = Logger.new($stdout) }\nTypedBus.logger = Logger.new($stdout)\n\n# Reading:\nTypedBus.logger  # =&gt; the Logger instance\n</code></pre> <p>Setting <code>log_level</code> automatically applies it to the current logger. Setting a logger automatically applies the current <code>log_level</code> to it.</p>"},{"location":"getting-started/configuration/#reset","title":"Reset","text":"<p>Restore factory defaults (useful in tests):</p> <pre><code>TypedBus.reset_configuration!\n</code></pre>"},{"location":"getting-started/configuration/#further-reading","title":"Further Reading","text":"<ul> <li>Configuration Cascade \u2014 architecture details</li> <li>API Reference: Configuration \u2014 full method reference</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.2.0</li> <li>async ~&gt; 2.0</li> </ul>"},{"location":"getting-started/installation/#bundler","title":"Bundler","text":"<p>Add to your Gemfile:</p> <pre><code>gem \"typed_bus\"\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"getting-started/installation/#manual","title":"Manual","text":"<pre><code>gem install typed_bus\n</code></pre>"},{"location":"getting-started/installation/#verify","title":"Verify","text":"<pre><code>require \"typed_bus\"\nputs TypedBus::VERSION\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":""},{"location":"getting-started/quick-start/#minimal-example","title":"Minimal Example","text":"<pre><code>require \"typed_bus\"\n\nbus = TypedBus::MessageBus.new\nbus.add_channel(:events, timeout: 5)\n\nbus.subscribe(:events) do |delivery|\n  puts \"Received: #{delivery.message}\"\n  delivery.ack!\nend\n\nAsync do\n  bus.publish(:events, \"hello world\")\nend\n</code></pre>"},{"location":"getting-started/quick-start/#what-just-happened","title":"What Just Happened","text":"<ol> <li>Created a bus \u2014 <code>MessageBus.new</code> creates a registry for channels with shared stats.</li> <li>Added a channel \u2014 <code>:events</code> is a named topic with a 5-second delivery timeout.</li> <li>Subscribed \u2014 the block receives a <code>Delivery</code> envelope for each published message. The subscriber must call <code>ack!</code> or <code>nack!</code>.</li> <li>Published inside Async \u2014 channel operations create Async tasks internally, so <code>publish</code> must run within an Async reactor.</li> </ol>"},{"location":"getting-started/quick-start/#using-channels-directly","title":"Using Channels Directly","text":"<p>You don't need a MessageBus. Channels work standalone:</p> <pre><code>require \"typed_bus\"\n\nchannel = TypedBus::Channel.new(:greetings, timeout: 5)\n\nchannel.subscribe do |delivery|\n  puts delivery.message\n  delivery.ack!\nend\n\nAsync do\n  channel.publish(\"Hello, world!\")\nend\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration \u2014 set defaults at global, bus, and channel levels</li> <li>Typed Channels \u2014 constrain messages to a specific class</li> <li>Delivery and Acknowledgment \u2014 understand ack/nack lifecycle</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>In-depth guides for every TypedBus feature.</p> <ul> <li>Typed Channels \u2014 constrain messages to a specific class</li> <li>Delivery and Acknowledgment \u2014 ack/nack lifecycle and timeout behavior</li> <li>Dead Letter Queues \u2014 inspect, retry, and monitor failed deliveries</li> <li>Backpressure \u2014 bound channels and block publishers at capacity</li> <li>Adaptive Throttling \u2014 progressive backoff as channels fill</li> <li>Stats and Monitoring \u2014 per-channel counters</li> <li>Logging \u2014 structured log output</li> <li>Error Handling \u2014 exceptions, edge cases, and recovery</li> <li>Graceful Shutdown \u2014 close channels and drain state</li> </ul>"},{"location":"guides/adaptive-throttling/","title":"Adaptive Throttling","text":"<p>When a bounded channel approaches capacity, adaptive throttling progressively slows publishers before they hit the hard backpressure block.</p>"},{"location":"guides/adaptive-throttling/#enabling-throttling","title":"Enabling Throttling","text":"<p>Throttling requires <code>max_pending</code> to be set:</p> <pre><code>channel = TypedBus::Channel.new(:pipeline,\n  max_pending: 10,\n  throttle: 0.5,   # begin backoff at 50% remaining capacity\n  timeout: 5\n)\n</code></pre> <p>The <code>throttle</code> value is a <code>Float</code> between <code>0.0</code> (exclusive) and <code>1.0</code> (exclusive), representing the remaining-capacity ratio at which backoff begins.</p>"},{"location":"guides/adaptive-throttling/#backoff-curve","title":"Backoff Curve","text":"<p>Below the threshold, each publish sleeps for <code>1 / (max_pending * remaining_ratio)</code> seconds \u2014 an asymptotic delay that approaches infinity as remaining capacity approaches zero.</p> <p>With <code>max_pending: 10, throttle: 0.5</code>:</p> <pre><code>Publish  Pending  Remaining  Ratio  Delay\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1        0        10       1.0    \u2014\n  2        1         9       0.9    \u2014\n  3        2         8       0.8    \u2014\n  4        3         7       0.7    \u2014\n  5        4         6       0.6    \u2014\n  6        5         5       0.5    0.200s\n  7        6         4       0.4    0.250s\n  8        7         3       0.3    0.333s\n  9        8         2       0.2    0.500s\n 10        9         1       0.1    1.000s\n 11       10         0       0.0    hard block\n</code></pre> <p>The first 50% of capacity fills at full speed. The last 50% applies increasing delays.</p>"},{"location":"guides/adaptive-throttling/#threshold-selection","title":"Threshold Selection","text":"<p>Higher values begin backoff earlier (more conservative):</p> <pre><code>TypedBus::Channel.new(:conservative, max_pending: 100, throttle: 0.8)  # backoff at 80%\nTypedBus::Channel.new(:aggressive,   max_pending: 100, throttle: 0.3)  # backoff at 30%\n</code></pre>"},{"location":"guides/adaptive-throttling/#bus-level-default","title":"Bus-Level Default","text":"<p>Set a default throttle for all channels on a bus:</p> <pre><code>bus = TypedBus::MessageBus.new(throttle: 0.5)\n\nbus.add_channel(:orders, max_pending: 100)               # inherits 0.5\nbus.add_channel(:alerts, max_pending: 20, throttle: 0.3) # overrides to 0.3\nbus.add_channel(:logs,   max_pending: 50, throttle: 0.0) # disables throttle\n</code></pre>"},{"location":"guides/adaptive-throttling/#validation","title":"Validation","text":"<ul> <li><code>throttle</code> must be between <code>0.0</code> and <code>1.0</code> (exclusive)</li> <li><code>throttle</code> requires <code>max_pending</code> to be set (raises <code>ArgumentError</code> otherwise)</li> <li><code>throttle: 0.0</code> disables throttling (the default)</li> </ul>"},{"location":"guides/adaptive-throttling/#stats","title":"Stats","text":"<p>Each throttled publish increments the <code>:throttled</code> stat:</p> <pre><code>bus.stats[:orders_throttled]\n</code></pre>"},{"location":"guides/backpressure/","title":"Backpressure","text":"<p>Set <code>max_pending</code> to bound how many unresolved deliveries a channel allows. When the limit is reached, <code>publish</code> blocks the calling fiber until subscribers ACK and free capacity.</p>"},{"location":"guides/backpressure/#enabling-backpressure","title":"Enabling Backpressure","text":"<pre><code>channel = TypedBus::Channel.new(:work,\n  max_pending: 100,\n  timeout: 10\n)\n</code></pre> <p>Or via MessageBus:</p> <pre><code>bus.add_channel(:work, max_pending: 100)\n</code></pre> <p>Or via the configuration cascade:</p> <pre><code>TypedBus.configure { |c| c.max_pending = 500 }\nbus = TypedBus::MessageBus.new\nbus.add_channel(:work)  # inherits max_pending=500\n</code></pre>"},{"location":"guides/backpressure/#how-it-works","title":"How It Works","text":"<pre><code>sequenceDiagram\n    participant P as Publisher Fiber\n    participant C as Channel\n    participant S as Subscriber Fiber\n\n    P-&gt;&gt;C: publish(msg)\n    C--&gt;&gt;C: pending_count &gt;= max_pending?\n    Note over C: YES \u2014 block publisher\n    S-&gt;&gt;C: delivery.ack!\n    C--&gt;&gt;C: pending_count drops\n    C-&gt;&gt;P: resume (signal)\n    P-&gt;&gt;C: publish continues</code></pre> <ol> <li>Before fan-out, the channel checks <code>pending_deliveries.size &gt;= max_pending</code></li> <li>If at capacity, the publishing fiber waits on an <code>Async::Condition</code></li> <li>When any delivery tracker resolves (all subscribers responded), the condition signals</li> <li>The publisher wakes and proceeds</li> </ol>"},{"location":"guides/backpressure/#unbounded-channels","title":"Unbounded Channels","text":"<p>Set <code>max_pending: nil</code> (the default) for unbounded channels. Publishers never block.</p>"},{"location":"guides/backpressure/#interaction-with-throttling","title":"Interaction with Throttling","text":"<p>When both <code>max_pending</code> and <code>throttle</code> are set, throttling runs first. The throttle progressively slows publishers as capacity fills; backpressure is the hard stop at zero remaining capacity.</p> <p>See Adaptive Throttling for details.</p>"},{"location":"guides/dead-letter-queues/","title":"Dead Letter Queues","text":"<p>Every channel has a dead letter queue (DLQ) that collects failed deliveries.</p>"},{"location":"guides/dead-letter-queues/#what-goes-to-the-dlq","title":"What Goes to the DLQ","text":"<ul> <li>Deliveries explicitly NACKed by subscribers</li> <li>Deliveries that time out (auto-nack)</li> <li>Messages published with no subscribers</li> </ul>"},{"location":"guides/dead-letter-queues/#accessing-the-dlq","title":"Accessing the DLQ","text":"<p>Via MessageBus:</p> <pre><code>dlq = bus.dead_letters(:orders)\n</code></pre> <p>Via Channel directly:</p> <pre><code>dlq = channel.dead_letter_queue\n</code></pre>"},{"location":"guides/dead-letter-queues/#inspecting-entries","title":"Inspecting Entries","text":"<pre><code>dlq.size     # number of entries\ndlq.empty?   # true if no entries\n\ndlq.each do |delivery|\n  puts \"#{delivery.message} failed on subscriber ##{delivery.subscriber_id}\"\n  puts \"  timed out? #{delivery.timed_out?}\"\nend\n</code></pre> <p>The DLQ includes <code>Enumerable</code>, so you can use <code>map</code>, <code>select</code>, <code>count</code>, etc.</p>"},{"location":"guides/dead-letter-queues/#draining-for-retry","title":"Draining for Retry","text":"<p><code>drain</code> yields each entry and removes it from the queue:</p> <pre><code>channel.dead_letter_queue.drain do |delivery|\n  retry_message(delivery.message)\nend\n</code></pre> <p>Without a block, <code>drain</code> returns the array of drained entries:</p> <pre><code>entries = channel.dead_letter_queue.drain\nentries.each { |d| reprocess(d.message) }\n</code></pre>"},{"location":"guides/dead-letter-queues/#real-time-callback","title":"Real-Time Callback","text":"<p>Register a callback that fires whenever a new entry arrives:</p> <pre><code>channel.dead_letter_queue.on_dead_letter do |delivery|\n  alert(\"Dead letter on :#{delivery.channel_name}: #{delivery.message}\")\nend\n</code></pre>"},{"location":"guides/dead-letter-queues/#clearing","title":"Clearing","text":"<p>Discard all DLQ entries:</p> <pre><code>channel.dead_letter_queue.clear!\n</code></pre> <p>Or clear the entire channel (including DLQ, pending deliveries, and timeout tasks):</p> <pre><code>channel.clear!\n</code></pre>"},{"location":"guides/delivery-and-ack/","title":"Delivery and Acknowledgment","text":"<p>Every subscriber receives a <code>Delivery</code> envelope wrapping the published message. The subscriber must explicitly resolve the delivery.</p>"},{"location":"guides/delivery-and-ack/#the-delivery-envelope","title":"The Delivery Envelope","text":"<pre><code>channel.subscribe do |delivery|\n  delivery.message        # the published object\n  delivery.channel_name   # :orders\n  delivery.subscriber_id  # integer ID assigned at subscribe time\n\n  delivery.ack!           # success\n  # or\n  delivery.nack!          # failure \u2192 routes to dead letter queue\nend\n</code></pre>"},{"location":"guides/delivery-and-ack/#acknowledgment-rules","title":"Acknowledgment Rules","text":"<ul> <li>Each delivery must be resolved exactly once with <code>ack!</code> or <code>nack!</code></li> <li>Calling <code>ack!</code> or <code>nack!</code> a second time raises <code>RuntimeError</code></li> <li>If neither is called before the channel's <code>timeout</code>, the delivery auto-nacks</li> </ul>"},{"location":"guides/delivery-and-ack/#delivery-states","title":"Delivery States","text":"Method Description <code>pending?</code> Not yet resolved <code>acked?</code> Successfully acknowledged <code>nacked?</code> Explicitly rejected or timed out <code>timed_out?</code> <code>true</code> if the nack was caused by timeout"},{"location":"guides/delivery-and-ack/#timeout-behavior","title":"Timeout Behavior","text":"<p>When a delivery times out:</p> <ol> <li><code>timed_out?</code> returns <code>true</code></li> <li>The delivery is automatically NACKed</li> <li>It routes to the dead letter queue</li> <li>The <code>:timed_out</code> and <code>:dead_lettered</code> stats increment</li> </ol> <pre><code>channel = TypedBus::Channel.new(:work, timeout: 2)\n\nchannel.subscribe do |delivery|\n  sleep 5  # exceeds the 2s timeout\n  delivery.ack!  # raises \u2014 already resolved by timeout\nend\n</code></pre> <p>Use <code>timed_out?</code> to distinguish timeouts from explicit nacks when processing the DLQ:</p> <pre><code>channel.dead_letter_queue.each do |delivery|\n  if delivery.timed_out?\n    # retry \u2014 subscriber was too slow\n  else\n    # investigate \u2014 subscriber explicitly rejected\n  end\nend\n</code></pre>"},{"location":"guides/delivery-and-ack/#multiple-subscribers","title":"Multiple Subscribers","text":"<p>When a message has multiple subscribers, each gets its own independent Delivery:</p> <pre><code>bus.add_channel(:events, timeout: 5)\nbus.subscribe(:events) { |d| d.ack! }      # subscriber 1\nbus.subscribe(:events) { |d| d.nack! }     # subscriber 2\n</code></pre> <p>The message is \"delivered\" (<code>:delivered</code> stat) only when all subscribers ACK. If any subscriber NACKs, only that subscriber's Delivery goes to the DLQ.</p>"},{"location":"guides/delivery-and-ack/#deliverytracker","title":"DeliveryTracker","text":"<p><code>publish</code> returns a <code>DeliveryTracker</code> that aggregates subscriber responses:</p> <pre><code>Async do\n  tracker = channel.publish(message)\n  # tracker.fully_delivered?  \u2014 all acked?\n  # tracker.fully_resolved?   \u2014 all responded?\n  # tracker.pending_count     \u2014 still waiting on N\nend\n</code></pre> <p>Returns <code>nil</code> if there are no subscribers (message goes directly to DLQ).</p>"},{"location":"guides/error-handling/","title":"Error Handling","text":"<p>TypedBus handles errors predictably at every level.</p>"},{"location":"guides/error-handling/#subscriber-exceptions","title":"Subscriber Exceptions","text":"<p>If a subscriber block raises, the delivery is auto-NACKed and routed to the DLQ:</p> <pre><code>bus.subscribe(:orders) do |delivery|\n  raise \"something broke\"\n  # delivery is auto-nacked, exception is logged\nend\n</code></pre> <p>The exception is rescued within the subscriber's Async task. Other subscribers and the channel continue operating normally.</p>"},{"location":"guides/error-handling/#type-mismatches","title":"Type Mismatches","text":"<p>Publishing a message that doesn't match the channel's type raises <code>ArgumentError</code> at the publish site:</p> <pre><code>bus.add_channel(:orders, type: Order)\n\nAsync do\n  bus.publish(:orders, \"not an order\")\n  # =&gt; ArgumentError: Expected Order, got String on channel :orders\nend\n</code></pre>"},{"location":"guides/error-handling/#unknown-channels","title":"Unknown Channels","text":"<p>All MessageBus methods that take a channel name raise <code>ArgumentError</code> for unknown channels:</p> <pre><code>bus.publish(:nonexistent, \"msg\")\n# =&gt; ArgumentError: Unknown channel: nonexistent\n\nbus.subscribe(:nonexistent) { |d| d.ack! }\n# =&gt; ArgumentError: Unknown channel: nonexistent\n</code></pre> <p><code>remove_channel</code> is the exception \u2014 it's a no-op for unknown channels.</p>"},{"location":"guides/error-handling/#publishing-to-a-closed-channel","title":"Publishing to a Closed Channel","text":"<pre><code>bus.close(:orders)\nbus.publish(:orders, \"msg\")\n# =&gt; RuntimeError: Channel :orders is closed\n</code></pre>"},{"location":"guides/error-handling/#subscribing-to-a-closed-channel","title":"Subscribing to a Closed Channel","text":"<pre><code>bus.close(:orders)\nbus.subscribe(:orders) { |d| d.ack! }\n# =&gt; RuntimeError: Channel :orders is closed\n</code></pre>"},{"location":"guides/error-handling/#double-resolution","title":"Double Resolution","text":"<p>Calling <code>ack!</code> or <code>nack!</code> on an already-resolved delivery raises <code>RuntimeError</code>:</p> <pre><code>bus.subscribe(:orders) do |delivery|\n  delivery.ack!\n  delivery.ack!   # =&gt; RuntimeError: Delivery already resolved as acked\nend\n</code></pre>"},{"location":"guides/error-handling/#no-subscribers","title":"No Subscribers","text":"<p>Messages published with no subscribers go directly to the DLQ:</p> <pre><code>bus.add_channel(:empty)\nAsync { bus.publish(:empty, \"orphan\") }\n\nbus.dead_letters(:empty).size  # =&gt; 1\n</code></pre>"},{"location":"guides/error-handling/#throttle-validation","title":"Throttle Validation","text":"<ul> <li><code>throttle</code> without <code>max_pending</code> raises <code>ArgumentError</code></li> <li><code>throttle</code> outside <code>(0.0, 1.0)</code> raises <code>ArgumentError</code></li> </ul> <pre><code>TypedBus::Channel.new(:bad, throttle: 0.5, timeout: 5)\n# =&gt; ArgumentError: throttle requires max_pending on channel :bad\n</code></pre>"},{"location":"guides/graceful-shutdown/","title":"Graceful Shutdown","text":"<p>TypedBus provides several levels of cleanup for stopping channels and buses.</p>"},{"location":"guides/graceful-shutdown/#close-a-channel","title":"Close a Channel","text":"<p>Stops accepting new publishes and subscribes. Pending deliveries are force-NACKed and routed to the DLQ.</p> <pre><code>channel.close\nchannel.closed?  # =&gt; true\n</code></pre> <p>After closing:</p> <ul> <li><code>publish</code> raises <code>RuntimeError</code></li> <li><code>subscribe</code> raises <code>RuntimeError</code></li> <li>The DLQ retains its entries for inspection</li> </ul>"},{"location":"guides/graceful-shutdown/#close-all-channels","title":"Close All Channels","text":"<pre><code>bus.close_all\n</code></pre> <p>Closes every channel on the bus. Each channel's pending deliveries are force-NACKed.</p>"},{"location":"guides/graceful-shutdown/#clear-a-channel","title":"Clear a Channel","text":"<p>Hard reset: cancels all timeout tasks, discards pending deliveries, and clears the DLQ.</p> <pre><code>channel.clear!\n</code></pre> <p>Unlike <code>close</code>, <code>clear!</code> does not mark the channel as closed \u2014 you can continue using it.</p>"},{"location":"guides/graceful-shutdown/#clear-a-bus","title":"Clear a Bus","text":"<p>Clears all channels and resets stats:</p> <pre><code>bus.clear!\n</code></pre>"},{"location":"guides/graceful-shutdown/#remove-a-channel","title":"Remove a Channel","text":"<p>Close and remove a channel from the bus registry:</p> <pre><code>bus.remove_channel(:orders)\nbus.channel?(:orders)  # =&gt; false\n</code></pre> <p>Removing a nonexistent channel is a no-op.</p>"},{"location":"guides/graceful-shutdown/#shutdown-order","title":"Shutdown Order","text":"<p>For a clean shutdown:</p> <ol> <li>Stop publishing new messages</li> <li>Wait for pending deliveries to resolve (or let timeouts fire)</li> <li>Process any DLQ entries</li> <li>Call <code>bus.close_all</code></li> </ol> <pre><code>Async do\n  # ... normal operations ...\n\n  # Shutdown\n  sleep(timeout_duration)  # let pending deliveries settle\n  bus.dead_letters(:orders).drain { |d| reprocess(d.message) }\n  bus.close_all\nend\n</code></pre>"},{"location":"guides/logging/","title":"Logging","text":"<p>TypedBus produces structured log output from all components when a logger is configured.</p>"},{"location":"guides/logging/#enabling-logging","title":"Enabling Logging","text":"<pre><code>TypedBus.configure do |config|\n  config.logger    = Logger.new($stdout)\n  config.log_level = Logger::INFO\nend\n</code></pre> <p>Or use the shortcut:</p> <pre><code>TypedBus.logger = Logger.new($stdout)\n</code></pre> <p>Set to <code>nil</code> (the default) to disable logging.</p>"},{"location":"guides/logging/#log-level","title":"Log Level","text":"<p>Setting <code>log_level</code> automatically applies it to the logger:</p> <pre><code>TypedBus.configure do |config|\n  config.logger    = Logger.new($stdout)\n  config.log_level = Logger::DEBUG     # applies to the logger\nend\n\n# Or change it later:\nTypedBus.configuration.log_level = Logger::WARN\n</code></pre>"},{"location":"guides/logging/#what-gets-logged","title":"What Gets Logged","text":""},{"location":"guides/logging/#info-level","title":"INFO Level","text":"<ul> <li>Bus initialization</li> <li>Channel creation with parameters</li> <li>Subscriber registration and unsubscription</li> <li>Message publish events</li> <li>Delivery acks</li> <li>DLQ drains</li> <li>Channel close and clear operations</li> </ul>"},{"location":"guides/logging/#warn-level","title":"WARN Level","text":"<ul> <li>Delivery nacks</li> <li>Delivery timeouts</li> <li>DLQ entries added</li> <li>Publishing with no subscribers</li> </ul>"},{"location":"guides/logging/#error-level","title":"ERROR Level","text":"<ul> <li>Subscriber exceptions</li> <li>Type mismatches</li> </ul>"},{"location":"guides/logging/#debug-level","title":"DEBUG Level","text":"<ul> <li>Individual subscriber notifications</li> <li>Throttle delay calculations</li> <li>Backpressure wait/resume events</li> </ul>"},{"location":"guides/logging/#log-format","title":"Log Format","text":"<p>All log messages are prefixed with the originating component:</p> <pre><code>TypedBus::MessageBus message bus initialized (default_throttle=off)\nTypedBus::Channel[:orders] channel created (type=Order, timeout=10s, max_pending=100, throttle=off)\nTypedBus::Channel[:orders] published message (type=Order, subscribers=2)\nTypedBus::Delivery[:orders#1] acked\nTypedBus::DeliveryTracker[:orders] fully delivered (all 2 subscribers acked)\n</code></pre>"},{"location":"guides/logging/#custom-formatter","title":"Custom Formatter","text":"<p>Use a custom formatter for colorized or structured output:</p> <pre><code>logger = Logger.new($stdout)\nlogger.formatter = proc do |severity, datetime, _progname, msg|\n  timestamp = datetime.strftime(\"%H:%M:%S.%L\")\n  \"#{timestamp} [#{severity.ljust(5)}] #{msg}\\n\"\nend\n\nTypedBus.configure do |config|\n  config.logger    = logger\n  config.log_level = Logger::DEBUG\nend\n</code></pre>"},{"location":"guides/stats-and-monitoring/","title":"Stats and Monitoring","text":"<p><code>MessageBus</code> tracks per-channel counters automatically via a shared <code>Stats</code> instance.</p>"},{"location":"guides/stats-and-monitoring/#available-counters","title":"Available Counters","text":"<p>For each channel named <code>:orders</code>, the following counters are tracked:</p> Counter Description <code>:orders_published</code> Messages published <code>:orders_delivered</code> All subscribers ACKed (message fully delivered) <code>:orders_nacked</code> Explicit nacks by subscribers <code>:orders_timed_out</code> Delivery timeouts (auto-nack) <code>:orders_dead_lettered</code> Entries added to the DLQ <code>:orders_throttled</code> Publishes that were rate-limited"},{"location":"guides/stats-and-monitoring/#reading-stats","title":"Reading Stats","text":"<pre><code>bus.stats[:orders_published]     # =&gt; 42\nbus.stats[:orders_delivered]     # =&gt; 40\nbus.stats[:orders_dead_lettered] # =&gt; 2\n</code></pre>"},{"location":"guides/stats-and-monitoring/#snapshot","title":"Snapshot","text":"<p>Get all counters as a Hash:</p> <pre><code>bus.stats.to_h\n# =&gt; { orders_published: 42, orders_delivered: 40, ... }\n</code></pre>"},{"location":"guides/stats-and-monitoring/#reset","title":"Reset","text":"<p>Zero all counters:</p> <pre><code>bus.stats.reset!\n</code></pre> <p>Or reset everything (channels + stats):</p> <pre><code>bus.clear!\n</code></pre>"},{"location":"guides/stats-and-monitoring/#using-stats-directly","title":"Using Stats Directly","text":"<p>When using <code>Channel</code> without a <code>MessageBus</code>, pass a <code>Stats</code> instance:</p> <pre><code>stats = TypedBus::Stats.new\nchannel = TypedBus::Channel.new(:work, stats: stats, timeout: 5)\n\n# ... publish and subscribe ...\n\nstats[:work_published]  # =&gt; N\n</code></pre>"},{"location":"guides/stats-and-monitoring/#monitoring-pattern","title":"Monitoring Pattern","text":"<p>Combine stats with DLQ callbacks for real-time alerting:</p> <pre><code>bus.add_channel(:orders, timeout: 10)\n\nbus.dead_letters(:orders).on_dead_letter do |delivery|\n  error_rate = bus.stats[:orders_dead_lettered].to_f / bus.stats[:orders_published]\n  if error_rate &gt; 0.1\n    alert(\"Orders DLQ error rate above 10%: #{(error_rate * 100).round}%\")\n  end\nend\n</code></pre>"},{"location":"guides/typed-channels/","title":"Typed Channels","text":"<p>Channels can enforce a type constraint on published messages. When set, every message must pass an <code>is_a?</code> check against the specified class.</p>"},{"location":"guides/typed-channels/#setting-a-type","title":"Setting a Type","text":"<pre><code>channel = TypedBus::Channel.new(:orders, type: Order, timeout: 5)\n</code></pre> <p>Or via MessageBus:</p> <pre><code>bus.add_channel(:orders, type: Order)\n</code></pre>"},{"location":"guides/typed-channels/#type-enforcement","title":"Type Enforcement","text":"<pre><code>Async do\n  channel.publish(Order.new)    # OK\n  channel.publish(\"not valid\")  # raises ArgumentError\nend\n</code></pre> <p>The error message includes both the expected and actual types:</p> <pre><code>Expected Order, got String on channel :orders (ArgumentError)\n</code></pre>"},{"location":"guides/typed-channels/#subclasses","title":"Subclasses","text":"<p>The check uses <code>is_a?</code>, so subclasses pass:</p> <pre><code>class PriorityOrder &lt; Order; end\n\nchannel = TypedBus::Channel.new(:orders, type: Order, timeout: 5)\n\nAsync do\n  channel.publish(PriorityOrder.new)  # OK \u2014 PriorityOrder is_a? Order\nend\n</code></pre>"},{"location":"guides/typed-channels/#untyped-channels","title":"Untyped Channels","text":"<p>Omit <code>type:</code> (or pass <code>nil</code>) to accept any message:</p> <pre><code>bus.add_channel(:events)  # accepts anything\n</code></pre>"},{"location":"guides/typed-channels/#when-to-use-types","title":"When to Use Types","text":"<p>Type constraints are useful when:</p> <ul> <li>Multiple publishers share a channel and you want compile-time-like safety</li> <li>Messages carry structured data (Structs, Data classes) and you want to catch serialization mistakes early</li> <li>You want to document the channel's contract in code</li> </ul> <p>Note</p> <p>The <code>type:</code> parameter is per-channel only. It is not part of the configuration cascade \u2014 there is no meaningful \"default type.\"</p>"}]}